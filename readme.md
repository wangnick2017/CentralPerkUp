# RISCV-CPU

一个基本实现了RISCV 32位整数指令集的CPU。

## 概要

该项目是 System 2018 的大作业，使用 Verilog 语言，实现一个简单的 CPU，并在 FPGA 上进行烧写测试。该报告介绍了一些该项目的设计细节和经验总结。

## 一些细节

### 五周期的访存操作

因为这次作业的内存设计在板子上，一次读写只能走8 bit（1字节），所以取指令和大量访存操作都要4次内存读写（至少要5周期），所以我设计了一个5周期访存的内存控制器，用状态机实现，控制IF和MEM阶段的内存操作。以下是其中的一些要点：

- IF和MEM同时有访存需求时，优先处理MEM；

- 第五周期取到数据的最后一部分时，立刻用组合逻辑将数据送到流水线上，以保证下一周期的IF和ID顺利接班。

### I-Cache

为了让五级流水真正地留起来，加入了I-Cache。这是一个非常简单的直接映射Cache，用pc的第2-7位作为索引，因为内存中指令部分不会被更改，所以该Cache不用考虑写操作的问题。

当然，加入了I-Cache，内存控制器就必须要谨慎处理各类读取操作和是否miss的关系了。在此期间，很多原本没发现的流水错误也都暴露出来了，例如无法用forwarding解决的数据Hazard，让我调了好久。

### 分支预测？

原本是计划写一个分支预测的，动态分支预测太难写而且板上接线容易乱掉，就设计了一个静态分支预测。写的过程中发现了一个问题：若没有BTB，那么是否实现静态分支预测就只有一个周期的差距，而且只是针对于六种branch最后不跳转的情况。预测失败时还要在一个周期内打断已经取指了一部分的（假）下一条指令，并立刻开始准备新指令的读取，否则预测成功的优势就会因为预测失败的延迟而失去了。

经过一番思考与尝试，我还是放弃了实现分支预测，因为我觉得若强行照着上面的思路实现并不影响原有的设计的话，线路会又乱又杂很可能只有降频才能满足时序了。最后，我的策略是在IF阶段就判断出当前指令是不是分支指令，如果是，在当前指令的ID阶段结束前不要再IF了，一般来讲，这样只会耽误一个周期，在其他地方流水很充足的情况下并无太大的性能影响。

## 接线与板上元件的使用状况

- <img src="img\\net.png" width="75%" height="75%">
- <img src="img\\design.png" width="25%" height="25%">

## 一些测试结果

- pi.c 1.5-1.6s **升频到125MHz后为1.1-1.2s**

- qsort.c 5.2-6.8s

- queens.c 2.1-2.2s

- bulgarian.c 0.6-0.7s

- hanoi.c 2.5-2.6s

    <img src="img\\test.png" width="70%" height="70%">

## 写在最后

就像我在presentation中说的，这个CPU经历了反复的修补，也让我发现了自己遗漏的各种知识点和没有推敲过的细节。对着波形图查错的过程真令人头皮发麻，但是纠出了错误的那一刻真的好开心！

非常感谢各位助教和同学们在此期间提供的帮助！！

2018年12月30日